/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  PropertySelectionModal: () => PropertySelectionModal,
  default: () => LiveVariable
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// utils.ts
var getValueByPath = (obj, path) => {
  const keys = path.split(/\.|\[|\]/).filter(Boolean);
  return keys.reduce((acc, key) => {
    if (acc && typeof acc === "object" && acc.hasOwnProperty(key)) {
      return acc[key];
    }
    return void 0;
  }, obj);
};
var getAllNestedKeyValuePairs = (obj) => {
  const result = [];
  function recurse(currentObj, currentPath) {
    if (currentPath) {
      result.push([currentPath, currentObj]);
    }
    if (typeof currentObj === "object" && currentObj !== null) {
      if (Array.isArray(currentObj)) {
        currentObj.forEach((item, index) => {
          recurse(item, `${currentPath}[${index}]`);
        });
      } else {
        for (const key in currentObj) {
          if (currentObj.hasOwnProperty(key)) {
            recurse(
              currentObj[key],
              currentPath ? `${currentPath}.${key}` : key
            );
          }
        }
      }
    }
  }
  recurse(obj, "");
  return result;
};
var stringifyIfObj = (obj) => {
  if (typeof obj === "object") {
    return JSON.stringify(obj);
  }
  return String(obj);
};

// main.ts
var LiveVariable = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.propertyChanged = (currentProperties, newProperties) => {
      for (const [newPropKey, newPropVal] of Object.entries(
        newProperties != null ? newProperties : {}
      )) {
        const currentPropVal = currentProperties == null ? void 0 : currentProperties[newPropKey];
        if (JSON.stringify(currentPropVal) !== JSON.stringify(newPropVal)) {
          return true;
        }
      }
      return false;
    };
  }
  async onload() {
    let fileProperties;
    await this.loadSettings();
    this.app.workspace.on("active-leaf-change", (leaf) => {
      var _a;
      const file = this.app.workspace.getActiveFile();
      if (file) {
        fileProperties = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        this.renderVariables(file);
      }
    });
    this.addCommand({
      id: "insert-local-variable",
      name: "Insert local variable",
      editorCallback: (editor, view) => {
        new PropertySelectionModal(
          this.app,
          view,
          false,
          (property) => {
            editor.replaceSelection(
              `<span id="${property.key}"/>${property.value}<span type="end"/>`
            );
            new import_obsidian.Notice(`Variable ${property.key} inserted`);
          }
        ).open();
      }
    });
    this.addCommand({
      id: "insert-global-variable",
      name: "Insert variable from another note",
      editorCallback: (editor, view) => {
        new PropertySelectionModal(this.app, view, true, (property) => {
          editor.replaceSelection(
            `<span id="${property.key}"/>${property.value}<span type="end"/>`
          );
          new import_obsidian.Notice(`Variable ${property.key} inserted`);
        }).open();
      }
    });
    this.registerEvent(
      this.app.metadataCache.on("changed", (path, _, cache) => {
        const frontmatterProperties = cache.frontmatter;
        if (!fileProperties) {
          fileProperties = frontmatterProperties;
          return;
        }
        const propertyChanged = this.propertyChanged(
          fileProperties,
          frontmatterProperties
        );
        if (propertyChanged) {
          const file = this.app.vault.getFileByPath(path.path);
          if (file) {
            this.renderVariables(file);
          }
          fileProperties = frontmatterProperties;
        }
      })
    );
  }
  renderVariables(file) {
    const re = new RegExp(
      String.raw`<span id="(.+?)"/>.+?<span type="end"/>`,
      "g"
    );
    this.app.vault.process(file, (data) => {
      [...data.matchAll(re)].forEach((match) => {
        var _a;
        const key = match[1];
        const lastSlashIndex = key.lastIndexOf("/");
        let variableId;
        let variableFile;
        if (lastSlashIndex === -1) {
          variableFile = file;
          variableId = key;
        } else {
          const filePath = key.substring(0, lastSlashIndex);
          variableId = key.substring(lastSlashIndex + 1);
          variableFile = this.app.vault.getFileByPath(filePath);
        }
        if (variableFile) {
          const value = getValueByPath(
            (_a = this.app.metadataCache.getFileCache(variableFile)) == null ? void 0 : _a.frontmatter,
            variableId
          );
          data = data.replace(
            match[0],
            `<span id="${key}"/>${stringifyIfObj(value)}<span type="end"/>`
          );
        }
      });
      return data;
    });
  }
  onunload() {
  }
  async loadSettings() {
  }
  async saveSettings() {
  }
};
var PropertySelectionModal = class extends import_obsidian.SuggestModal {
  constructor(app, view, global, onSelect) {
    super(app);
    this.view = view;
    this.global = global;
    this.onSelect = onSelect;
  }
  getSuggestions(query) {
    if (this.global) {
      return this.getGlobalSuggestions(query);
    }
    return this.getLocalSuggestions(query);
  }
  getLocalSuggestions(query) {
    var _a, _b;
    if (this.view.file) {
      const properties = (_b = (_a = this.app.metadataCache.getFileCache(this.view.file)) == null ? void 0 : _a.frontmatter) != null ? _b : {};
      return getAllNestedKeyValuePairs(properties).filter(
        (property) => property[0].toLowerCase().includes(query.toLowerCase())
      ).map((entry) => ({
        key: entry[0],
        value: stringifyIfObj(entry[1])
      }));
    }
    return [];
  }
  getGlobalSuggestions(query) {
    const properties = Object.assign(
      {},
      ...this.app.vault.getFiles().flatMap((file) => {
        var _a;
        let props = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        if (props) {
          props = Object.fromEntries(
            getAllNestedKeyValuePairs(props).map(([k, v]) => [
              file.path + "/" + k,
              v
            ])
          );
        }
        return props;
      })
    );
    return Object.entries(properties).filter(
      (property) => property[0].toLowerCase().includes(query.toLowerCase())
    ).map((entry) => ({ key: entry[0], value: stringifyIfObj(entry[1]) }));
  }
  renderSuggestion(property, el) {
    el.createEl("div", { text: property.key });
    el.createEl("small", { text: property.value.substring(0, 100) + (property.value.length > 100 ? "..." : "") });
  }
  onChooseSuggestion(property, evt) {
    this.onSelect(property);
  }
};


/* nosourcemap */